{% extends "db/base.html" %}
{% block content %}

<link rel="stylesheet" type="text/css" href="{{ STATIC_URL }}css/backgrid.css" />
<link rel="stylesheet" type="text/css" href="{{ STATIC_URL }}css/backgrid-paginator.css" />
<link rel="stylesheet" type="text/css" href="{{ STATIC_URL }}css/backgrid-filter.css" />

<script type='text/javascript' src='{{ STATIC_URL }}js/underscore.js'></script>
<script type='text/javascript' src='{{ STATIC_URL }}js/backbone.js'></script>
<script type='text/javascript' src='{{ STATIC_URL }}js/backbone-pageable.js'></script>
<script type='text/javascript' src='{{ STATIC_URL }}js/backbone-tastypie.js'></script>
<script type='text/javascript' src='{{ STATIC_URL }}js/backgrid.js'></script>
<script type='text/javascript' src='{{ STATIC_URL }}js/backgrid-paginator.js'></script>

<!--TODO: lunr is a dependency of backgrid-filter.js but shouldn't be - its for client side filtering -->
<script type='text/javascript' src='{{ STATIC_URL }}js/lunr.js'></script>
<script type='text/javascript' src='{{ STATIC_URL }}js/backgrid-filter.js'></script>
<script type='text/javascript' src='{{ STATIC_URL }}js/spin.min.js'></script>

<script type='text/javascript' src='{{ STATIC_URL }}/js/iccbl-lims.js'></script>

<!--
<link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.no-icons.min.css" rel="stylesheet">
<link href="//netdna.bootstrapcdn.com/font-awesome/3.1.1/css/font-awesome.css" rel="stylesheet">
-->
<style type="text/css">
	@media screen{
		.table th, .table td {
			padding: 1px;
		}
	/*hack to make the header fit the filter search box and side icons (side icons are the problem)*/
        .backgrid th {
            padding-right: 35px;
        }
        .form-horizontal .control-group {
            margin-bottom: 0px;
        }
        form {
            margin: 0 0 0px;
        }
        .loading1 {
            background:rgba(0,0,0,0.3);
        }
        #loading{
            position:fixed;
            z-index:999;
            top:0;
            left:0;
            width:100%;
            height: 100%;
            background: url('/static/images/ajax-loading2.gif')
                50% 20%
                no-repeat;
        }
    }
</style>
<script type="text/template" id="rows-per-page-template">
    <form class="form-horizontal">
        <div class="control-group">
            <label class="control-label" for="rowsperpage_selector">Rows per page:</label>
            <div class="controls">
                <select  class="input-mini" id="rowsperpage_selector">
                    <% options.each(function(option) { %>
                        <option value="<%= option %>"><%= option %></option>
                    <% }); %>
                </select>
            </div>
        </div>
    </form>
</script>
<script type="text/javascript">

$(document).ready(function(){
    var _url_schema = "{{api_url_schema}}";
    var _url = "{{api_url}}";

	window.App = {
	    Models: {},
	    Collections: {},
	    Views: {},
	    Router: {}
	};


	$.ajax({
		type: "GET",
       	url: _url_schema,
       	data: "",
       	dataType: "json",
       	success: function(result) {
       	    window.App.buildGrid(result.fields);

	   	}, // end success outer ajax call
		error: function(x, e) {
			alert(x.readyState + " "+ x.status +" "+ e.msg);
		}
	});


    var MyModel = Backbone.Model.extend({});

    var MyCollection = Backbone.PageableCollection.extend({
        searchBy: null,
        model: MyModel,
        url: _url,
        state: {
            pageSize: 25,
        },
        queryParams: {
            // adjust the query params for tastypie
            pageSize: 'limit',
            offset: function(){
                return (this.state.currentPage-1) * this.state.pageSize;
            },
            totalRecords: null, // unset for tastypie
            totalPages: null, // unset for tastypie
            sortKey: "order_by", // modified for tastypie
            order: null, // unset for tastypie
            order_by: function() { // modified for tastypie: use only "order_by=(-)field_name"
                if (typeof this.state !== 'undefined' && this.state.sortKey && this.state.order) {
                    var dir = "-";
                    if (this.state.order<0){  // according to docs, -1 == ascending
                        dir = "";
                    }
                    return dir + this.state.sortKey;
                }
            },

        },
        parse: function(response) {
            // hack the response for tastypie:
            // note, this is because the pageable collection doesn't work with the backbone-tastypie.js fix
            //this.state.totalRecords = response.meta.total_count;
            var state = _.clone(this.state);
            state.totalRecords = response.meta.total_count;
            if(Math.ceil(state.totalRecords/state.pageSize) < state.currentPage ){
                console.log('adjust currentPage');
                state.currentPage=1;
            }
            this.state = this._checkState(state); // recalculate the state and do sanity checks.
            console.log('new state: ' + JSON.stringify(this.state));
            this.setRoutes();
            return response.objects;
        },
        /**
           @property {-1|0|1} [state.order=-1] The order to use for sorting. Specify
           -1 for ascending order or 1 for descending order. If 0, no client side
           sorting will be done and the order query parameter will not be sent to
         */

        setRoutes: function() {
            console.log('setRoutes: ' + this.searchBy + ', '
                + this.state.sortKey + ', ' + this.state.order + ', '+ this.state.pageSize + ', ', + this.state.currentPage);
            var route = '';
            if(this.searchBy !== null){
                route += 'search/'+this.searchBy ;
            }
            if(this.state.sortKey !== null){
                var sortKey = this.state.sortKey;
                if(this.state.order > 0){
                    sortKey = '-' + sortKey;
                }
                if(route.length > 0) route += '/';

                route += 'order_by/' + sortKey;
                //router.navigate('order_by/' + sortKey +'/page/'+ this.state.currentPage);
            }
            if(route.length > 0) route += '/';

            route += 'rpp/' + this.state.pageSize + '/page/' + this.state.currentPage;

            // router.navigate('/page/'+ this.state.currentPage);
            router.navigate(route);
        },

        // Override
        setSorting: function(sortKey,order,options) { // override and hack in sorting URL support
            console.log('setSorting called: ' + sortKey+ ', order: ' + order + typeof(order) + ', options: ' + options );
            console.log('searchBy: ' + JSON.stringify(this.data));
            var dir = '-';
            var direction = 'descending';
            if(typeof order !== 'undefined' && order < 0){
                dir = '';
                direction = 'ascending';
            }
            var obj = Backbone.PageableCollection.prototype.setSorting.call(this,sortKey, order);

            //this.setRoutes();

            return obj;
        },

        // Override
        getPage: function(page) { // override and hack in paging URL support
            var obj = Backbone.PageableCollection.prototype.getPage.call(this,page);
            //this.setRoutes();
            return obj;
        },

        fetch: function(options) {
            model = this;
            if (typeof options !== 'undefined') { // TODO: review; find a better way to _always_ stop the ajax spinner
                options.error = function(resp){
                    if (error) error(model, resp, options);
                    window.App.ajaxComplete();
                    window.alert(error);
                };
            }
            return Backbone.PageableCollection.prototype.fetch.call(this,options);
        }


    });// end definition of Collection extension

    App._collection = new MyCollection();
    // TODO: look into the routing package for backbone: https://github.com/jhudson8/backbone-query-parameters
    App.Router = Backbone.Router.extend({
        routes: {
            '': 'index',
            'page/:page': 'toPage',
            'rpp/:rpp(/page/:page)': 'toRowsPerPage',
            'order_by/:orderBy(/rpp/:rpp)(/page/:page)': 'toOrderedToPage',
            'search/:searchBy(/order_by/:orderBy)(/rpp/:rpp)(/page/:page)': 'toSearchOrderedToPage',
            '*unknownAction': 'unknownAction',
        },

        unknownAction: function(unknownAction){
            alert('Unknown action entered: ' + unknownAction);
        },

        index: function(){
            console.log("Index route has been called..");
            App._collection.fetch();
        },
        toPage: function(page){
            // this is what hooks the URL read to the model action - sde
            console.log("toPage route: " + page);
            //App._collection.getPage(parseInt(page));
            this.toSearchOrderedPage(null, null, null, page);
        },
        toRowsPerPage: function(rpp,page){
            console.log("toRowsPerPage route: " + rpp + ", page: " + page);
            this.toSearchOrderedToPage(null, null, rpp, page);
        },
        toOrderedToPage: function(orderBy,rpp, page){
            console.log("toOrderedToPage route: " + orderBy + ", rpp: " + rpp + ", page: " + page);
            this.toSearchOrderedToPage(null, orderBy, rpp, page);
        },
        toSearchOrderedToPage: function(searchBy, orderBy,rpp, page){
            console.log("toSearchOrderedToPage route: searchBy: " + searchBy
                + ", order: "+  orderBy + ", rpp: " + rpp + ", page: " + page);

            if(typeof page !== 'undefined' && page !== null ){
                console.log('page: ' + page);
                // set the state instead, will be caught and used with a refresh
                //              App._collection.getPage(page);
                App._collection.state.currentPage = parseInt(page);
            }

            if(typeof rpp !== 'undefined' && rpp !== null ){
                console.log('rpp: ' + rpp);
                // set the state instead, will be caught and used with a refresh
                //              App._collection.getPage(page);
                App._collection.state.pageSize = parseInt(rpp);
                // TODO: catch when pageSize is too large
            }

            if(typeof orderBy !== 'undefined' && orderBy !== null ){
                var direction = 'ascending';
                var order = -1;
                if(orderBy.charAt(0) === '-'){
                    order = 1; // according to the docs, 1 == descending
                    direction = 'descending';
                    orderBy = orderBy.substring(1);
                }
                App._collection.state.sortKey = orderBy;
                App._collection.state.order = order;
                // Notify header cells
                App._collection.trigger("backgrid:sort", orderBy, direction, null, App._collection);
            }

            var data = {};
            if(typeof searchBy !== 'undefined' && searchBy !== null){
                App._collection.searchBy = searchBy;
                // TODO: only can search one term at a time
                var p = /([^=]+)=([^=]+)/
                var match = p.exec(searchBy);
                if (match){
                    // data[match[1] + '__contains'] = match[2];
                    // console.log('parsed search: ' + JSON.stringify(data));
                    var searchColumn = match[1];
                    var searchTerm = match[2];
                    console.log('parsed search: ' + searchColumn + ', ' + searchTerm );
                    // notify search listeners
                    App._collection.trigger("MyServerSideFilter:search", searchColumn, searchTerm, App._collection);
                 }
            }

            App._collection.fetch({reset: true});

            // this trigger is for the custom header
            // trigger the sort event to let the backgrid header cell know to change the sort indicator on the column
//              Backbone.PageableCollection.prototype.trigger(App._collection,"backgrid:sort", orderBy, direction, null, App._collection);
        },
    });

    var MyServerSideFilter = Backgrid.Extension.ServerSideFilter.extend({
        // override so that we can keep a handle to the containing column name.
        // TODO: can handle this with events instead (so that the filter notifies the containing headercell?)
        columnName : null,

        initialize: function (options) {
            this.columnName = options.columnName;
            Backgrid.Extension.ServerSideFilter.prototype.initialize.apply(this, [options])

        },

        // remove: function() {
          // this.model.unbind('change', this.render);
          // return Backbone.View.prototype.remove.apply(this, arguments);
        // },
    });

    var MyHeaderCell = Backgrid.HeaderCell.extend({
        _serverSideFilter : null,
        initialize: function (options) {
            // call the super constructor
            //MyHeaderCell.__super__.initialize(options);
            console.log('MyHeaderCell initialize');
            this.constructor.__super__.initialize.apply(this, [options])


            this._serverSideFilter = new MyServerSideFilter({
              collection: App._collection,
              name: this.column.get("name")+"__contains", // the name of the URL query parameter
              placeholder: "Search "+ this.column.get("label"), // HTML5 placeholder for the search box
              columnName: this.column.get("name"),
            });

            this.listenTo(this.collection, "MyServerSideFilter:search", this._search);

            this._serverSideFilter['events']['click .close'] = function(e) {
                if (e) e.preventDefault();

                this.remove(); // this is the filter
                this.clear();
                this.collection.searchBy = null;
            };

            // listen for search submission by the user and set the routes
            this._serverSideFilter['events']['submit'] = function(e) {
                // TODO: this should be handled by a backbone event
                this.collection.searchBy = this.columnName + '=' + this.$el.find("input[type=text]").val();
                this.collection.state.currentPage=1;  // if filtering, always set the page to 1
                //this.collection.setRoutes();
                this.search(e);
            };
        },


        // function to listen for router generated custom search event MyServerSideFilter:search
        _search: function(searchColumn, searchTerm, collection){
            if (collection == this.collection) {
                if (searchColumn !== this.column.get("name")){
                    // TODO: remove searchbox
                    this._serverSideFilter.remove();
                }else{
                    console.log('on MyServerSideFilter:search: ' + searchColumn );
                    this.$el.append(this._serverSideFilter.render().el); // create the DOM element
                    this._serverSideFilter.$el.find("input[type=text]").val(searchTerm) // set the search term

                    // it works to just call fetch, I think, because the super constructor has
                    // the following, which is run when server-side data is retreived.
                      // if (Backbone.PageableCollection &&
                          // collection instanceof Backbone.PageableCollection &&
                          // collection.mode == "server") {
                        // collection.queryParams[this.name] = function () {
                          // return self.$el.find("input[type=text]").val();
                        // };
                      // }
                    // TODO: it might be better to explicitly call this.search, (but how?) (i.e. some event...)

                    this.collection.fetch();
                }
            }

        },

      /**
         Renders a header cell with a sorter and a label.
       */
      render: function () {
        Backgrid.HeaderCell.prototype.render.apply(this);
        var _handle = this;
        var filterIcon = $('<i class="icon-search"></i>');
        filterIcon.click(function(e) {
            _handle.$el.append(_handle._serverSideFilter.render().el);
        });
        this.$el.prepend(filterIcon);
        return this;
      }
    });

    var router = new App.Router;

    var ItemsPerPageSelector = Backbone.View.extend({
//        el: $("#selector-div"), // view must have the element to get events for
        template: _.template($("#rows-per-page-template").html()),

        events: {
            "change #rowsperpage_selector": "setItemsPerPage"
        },

        initialize: function(options, collection){
            this.options = _(options);
            this.collection = collection;
            this.render();
        },
        setItemsPerPage: function(e){
            e.preventDefault();
            var option = e.currentTarget.value;
            console.log('option: ' + option + ', clicked');
            // this.collection.state.pageSize = parseInt(option);
            var state = _.clone(this.collection.state);
            state.pageSize = parseInt(option);
            if(Math.ceil(state.totalRecords/state.pageSize) < state.currentPage ){
                console.log('adjust currentPage');
                state.currentPage=Math.ceil(state.totalRecords/state.pageSize);
            }
            this.collection.state = this.collection._checkState(state); // recalculate the state and do sanity checks.

            this.collection.fetch({reset:true});
            //this.collection.setRoutes();
        },
        render: function(){
            var selector_template = _.template($("#rows-per-page-template").html(), {
                options: this.options,
            });
            this.$el.html(selector_template);
            this.delegateEvents();
            return this;
        },
        updateSelection: function(e){
            $('#rowsperpage_selector').val(String(this.collection.state.pageSize));
        },
    });

    var selector = new ItemsPerPageSelector(['25','50','200','1000'], App._collection);

    window.App.ajaxStart = function(){
        console.log("start spinner...");
        $('#loading').fadeIn({duration:100});
    };
    window.App.ajaxComplete = function(){
        console.log("stop spinner...");
        $('#loading').fadeOut({duration:100});
    };

    window.App.buildGrid = function(fieldDefinitions) {
        console.log('buildGrid...');
        var columns = iccbl.createBackgridColModel(fieldDefinitions, MyHeaderCell);
        var grid = new Backgrid.Grid({
          columns: columns,
          collection: App._collection
        });
        var exampleGrid = $("#example-table");
        // Render the grid and attach the root to your HTML document
        exampleGrid.append(grid.render().$el);

        // Initialize the paginator
        var paginator = new Backgrid.Extension.Paginator({
          columns: columns,
          collection: App._collection
        });

        // Render the paginator
        // exampleGrid.prepend(paginator.render().$el);
        $("#paginator-div").append(paginator.render().$el);
        $("#rows-selector-div").append(selector.render().$el);

        var allEvent = function(event){
            console.log("event fired: " + event);
        };
        App._collection.on({
          "all": allEvent,  // TODO: this is debug code
        });

        // TODO: tie these events into the collection override?
//        App._collection.bind('request', window.App.ajaxStart, this);
        App._collection.on('request', App.ajaxStart); // NOTE: can use bind or on
        App._collection.bind('sync', window.App.ajaxComplete, this);
        App._collection.bind('sync', selector.updateSelection, selector);  // TODO: selector.listenTo(App._collection, 'sync'...

        console.log('start history...');
        Backbone.history || (Backbone.history = new Backbone.History());
        Backbone.history.start({
          pushState: false,
          root: '/db/screeners2/'
        });
        console.log('initialized');
    }
});

</script>

<div class="container-fluid" style="margin-left: 0px; background-color: #c5d2db;">
    <div class="row-fluid no-space">
        <div class="span8" id="paginator-div"></div>
        <div class="span2" id="rows-selector-div"></div>
    </div>
    <div class="row-fluid no-space">
    	<div id="example-table" class='table-striped' ></div>
    </div><!-- table row -->
</div>
    <div id="loading"></div><!-- loading indicator -->
{% endblock %}
